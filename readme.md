
> Типикал машинное обучение:
> Имеются 3д модели объектов.
> Берем один кадр от 3д модели и получаем 2д модель.
> Ставим соответствие: 2д -> 3д.
> Заставляем модель сгенерировать 3д модель по 2д модели.


Моя задача.
Нужно по словесному описанию запроса и GraphQL схеме сгенерировать GraphQL запрос.

> Генерируем тучу схем и запросов к ним. (вкл-я валидацию запросов по схеме, аугментацию по сложности описания)
> По запросам генерируем описания.
> Ставим соответствие: схема+описание -> запрос.

Есть сложности, которые нужно учитывать.

## Размер GraphQL схемы

С большой схемой есть сложности - она не влезает в контекст.
Пусть максимальный размер схемы - 500кб. 

## Строгий формат GraphQL запросов

Сгенерированные GraphQL запросы должны быть валидными и соответствовать схеме.
Кажется, что популярные LLM для генерации запросов не годятся, потому что они генерируют просто текст.
Мне же в идеале генерировать AST запроса. AST можно представить в виде строки JSON.
Получается нейросеть должна генерировать JSON строку или некое дерево.


### Ориентация по графу GraphQL схемы

Необходимо по запросу определить список типов(вершин) и связей(ребер) между ними. 
Для этого использовать GNN модель. 

Далее можно сразу сгенерировать минимальный запрос по этому графу.
Нужно будет заполнить обязательные параметры в запросе.
~~> Возможно потребуется выбрать поля, которые не являются связями.~~
Вроде как можно генерировать и список листовых полей.

Связи между типами это только половина. Нужно еще формировать selectionSet из примитивных полей. 
В GraphQL это листовые поля. 

Далее можно запустить обычную LLM для добавления нужных параметров в запрос.

#### А получится ли обучить такую сеть?

Кстати граф оказывается по-прежнему здоровенным. 
Семплируем граф на подграфы _Query и _Mutation.


А еще нейросеть должна быть большим, чем просто text-to-graph.
Нужно еще догадываться добавлять не указанные поля в запрос, но которые ожидаются.


## Использовать структурированный вывод LLM

Для поиска списка подходящих классов. Далее тащим их SDL.
Далее формируем список связей между ними.
А может основываться не на GraphQL, а на model.xml со всеми связями оттуда?
Оттуда получим маленький граф со связями между классами.